[{"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/index.tsx":"1","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/JoinGame.tsx":"2","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/reducers/index.ts":"3","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/CreateGame.tsx":"4","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/Home.tsx":"5","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/actions/userActions.ts":"6","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/reducers/game.ts":"7","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/HintCell.tsx":"8","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/Scoreboard/Scorecard.tsx":"9","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameFuncs.tsx":"10","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/InputCell.tsx":"11","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/App.tsx":"12","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/Scoreboard/index.tsx":"13","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/index.tsx":"14"},{"size":710,"mtime":1614266988422,"results":"15","hashOfConfig":"16"},{"size":983,"mtime":1614209266576,"results":"17","hashOfConfig":"16"},{"size":150,"mtime":1614209266610,"results":"18","hashOfConfig":"16"},{"size":753,"mtime":1614209266561,"results":"19","hashOfConfig":"16"},{"size":431,"mtime":1614209266567,"results":"20","hashOfConfig":"16"},{"size":703,"mtime":1614209266600,"results":"21","hashOfConfig":"16"},{"size":917,"mtime":1614209266607,"results":"22","hashOfConfig":"16"},{"size":941,"mtime":1614266287646,"results":"23","hashOfConfig":"16"},{"size":501,"mtime":1614266233732,"results":"24","hashOfConfig":"16"},{"size":5392,"mtime":1614209266423,"results":"25","hashOfConfig":"16"},{"size":1648,"mtime":1614266214783,"results":"26","hashOfConfig":"16"},{"size":1223,"mtime":1614266465533,"results":"27","hashOfConfig":"16"},{"size":2244,"mtime":1614266276410,"results":"28","hashOfConfig":"16"},{"size":2429,"mtime":1614266305671,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"1j2uzk6",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"42"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/index.tsx",[],["62","63"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/JoinGame.tsx",[],["64","65"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/reducers/index.ts",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/CreateGame.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/Home.tsx",[],["66","67"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/actions/userActions.ts",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/reducers/game.ts",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/HintCell.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/Scoreboard/Scorecard.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameFuncs.tsx",["68"],"type getIndexes = (i: number, n: number) => number[];\n\n/* \nOh boi I get to explain this nightmare and you get to read it.\nThis file infers what the *Grid* state is base on the *Turns*\ninside the *Board* that delivered by the socket server.\n*/\n\nconst funcs = {\n  // This is the heart of this whole operation\n  // it creates the two arrays that will be used to help render the Grid's Cells\n  initGrid: (ta: Turn[], n: number) => {\n    let N = n * n;\n    let values = new Array(N * N).fill(0);\n    let players = new Array(N * N).fill(0);\n\n    /**************************\n    The order here is important\n    ***************************/\n    for (let i = 0; i < ta.length; i++) {\n      let turn = ta[i];\n      // First add the turn to the array\n      values[turn.index] = turn.value;\n      players[turn.index] = turn.player;\n\n      // Then get auto completes\n      let autos = funcs.autoComplete(turn.index, values, 3);\n      console.log(autos);\n      if (autos) {\n        for (let a of autos) {\n          if (a.value !== 0) {\n            values[a.index] = a.value;\n            players[a.index] = turn.player;\n          }\n        }\n      }\n    }\n\n    return { values, players };\n  },\n\n  // The next three functions help calculate how the Sudoku grid should be organized\n  // They only return INDEXES that are meant to point to one of the arrays from initGrid\n  // They do NOT return actual values from said arrays\n  getRow: (index: number, n: number) => {\n    let N = n * n;\n    let ri = ~~(index / N) * N;\n    let rowIndexes: number[] = Array.from(Array(N).keys()).map((e: number) => {\n      return ri + e;\n    });\n\n    return rowIndexes;\n  },\n\n  getCol: (index: number, n: number) => {\n    let N = n * n;\n    let ci = index % N;\n\n    let colIndexes: number[] = Array.from(Array(N).keys()).map((e: number) => {\n      return ci + N * e;\n    });\n\n    return colIndexes;\n  },\n\n  getBox: (index: number, n: number) => {\n    let N = n * n;\n    let rstart = ~~(index / (N * n));\n    let cstart = ~~((index % N) / n);\n    let start = rstart * N * n + cstart * n;\n    // console.log(start);\n\n    let boxIndexes: number[] = [];\n\n    for (let ri = 0; ri < n; ri++) {\n      for (let ci = 0; ci < n; ci++) {\n        boxIndexes.push(start + ci + ri * N);\n      }\n    }\n\n    return boxIndexes;\n  },\n\n  // This DOES return values, but inside of a set\n  // This is particularly useful for displaying Hints\n  getGroupSet: (index: number, arr: number[], n: number) => {\n    // console.time('getGroupSet');\n\n    let indexes = funcs\n      .getBox(index, n)\n      .concat(funcs.getCol(index, n))\n      .concat(funcs.getRow(index, n));\n    let all = indexes.map((e: number) => {\n      return arr[e];\n    });\n\n    let set = new Set(all);\n\n    // console.timeEnd('getGroupSet');\n    return set;\n  },\n\n  // Pretty simple, tests user input;\n  testInput: (index: number, arr: number[], n: number, value: number) => {\n    let set = funcs.getGroupSet(index, arr, n);\n\n    if (value > 0 && value <= n * n) {\n      if (set.has(value)) {\n        let indexes = Array.from(\n          new Set(\n            [\n              funcs.getRow(index, n),\n              funcs.getCol(index, n),\n              funcs.getBox(index, n),\n            ].flat()\n          )\n        );\n\n        return indexes.filter((e: number) => arr[e] === value);\n      } else {\n        return true;\n      }\n    } else {\n      return false;\n    }\n  },\n\n  // I'm sorry I almost completely forgot how this works\n  autoComplete: (\n    index: number,\n    arr: number[],\n    n: number,\n    autoArr: AutoComplete[] = []\n  ): any => {\n    let indexes = new Set(\n      [\n        funcs.getRow(index, n),\n        funcs.getCol(index, n),\n        funcs.getBox(index, n),\n      ].flat()\n    );\n\n    let found = Array.from(indexes)\n      .map((e: any) => {\n        return {\n          set: funcs.getGroupSet(e, arr, n),\n          index: e,\n        };\n      })\n      .filter((e) => e.set.size === n * n && arr[e.index] === 0);\n    console.log(found);\n\n    if (found.length > 0) {\n      let newArr = [...arr];\n\n      let autos = found.map((e) => {\n        e.set.delete(0);\n        let setArr = Array.from(e.set);\n        let boolArr = Array(n * n).fill(false);\n\n        for (let i = 0; i < setArr.length; i++) {\n          boolArr[setArr[i] - 1] = true;\n        }\n\n        let auto = {\n          index: e.index,\n          value: boolArr.findIndex((b: boolean) => !b) + 1,\n        };\n\n        newArr[auto.index] = auto.value;\n        found.forEach((e) => e.set.add(auto.value));\n\n        return auto;\n      });\n\n      // check if autocompleted cell will cause more autocompletes\n      let recusive = autos.map((e) => {\n        return funcs.autoComplete(e.index, newArr, n, [...autoArr, e]);\n      });\n\n      // let bigSet = new Set(autos.concat(recusive).flat());\n      let bigSet = autos.concat(recusive).flat();\n      console.log(bigSet);\n      return Array.from(bigSet);\n    } else {\n      // if no autocompletes were found, return what we got (or empty array)\n      return autoArr;\n    }\n  },\n};\n\nexport default funcs;\n/*     0        1        2\n0  00 01 02 03 04 05 06 07 08\n1  09 10 11 12 13 14 15 16 17 \n2  18 19 20 21 22 23 24 25 26 \n-      3        4        5\n3  27 28 29 30 31 32 33 34 35 \n4  36 37 38 39 40 41 42 43 44\n5  45 46 47 48 49 50 51 52 53 \n-      6        7        9\n6  54 55 56 57 58 59 60 61 62 \n7  63 64 65 66 67 68 69 70 71 \n8  72 73 74 75 76 77 78 79 80\n*/\n","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/InputCell.tsx",["69"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/App.tsx",["70"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/Scoreboard/index.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/index.tsx",["71"],{"ruleId":"72","replacedBy":"73"},{"ruleId":"74","replacedBy":"75"},{"ruleId":"72","replacedBy":"76"},{"ruleId":"74","replacedBy":"77"},{"ruleId":"72","replacedBy":"78"},{"ruleId":"74","replacedBy":"79"},{"ruleId":"80","severity":1,"message":"81","line":1,"column":6,"nodeType":"82","messageId":"83","endLine":1,"endColumn":16},{"ruleId":"84","severity":1,"message":"85","line":39,"column":6,"nodeType":"86","endLine":39,"endColumn":13,"suggestions":"87"},{"ruleId":"84","severity":1,"message":"88","line":26,"column":6,"nodeType":"86","endLine":26,"endColumn":15,"suggestions":"89"},{"ruleId":"80","severity":1,"message":"90","line":1,"column":17,"nodeType":"82","messageId":"83","endLine":1,"endColumn":23},"no-native-reassign",["91"],"no-negated-in-lhs",["92"],["91"],["92"],["91"],["92"],"@typescript-eslint/no-unused-vars","'getIndexes' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'keyHandler'. Either include it or remove the dependency array.","ArrayExpression",["93"],"React Hook useEffect has a missing dependency: 'history'. Either include it or remove the dependency array.",["94"],"'useRef' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"95","fix":"96"},{"desc":"97","fix":"98"},"Update the dependencies array to be: [keyHandler, value]",{"range":"99","text":"100"},"Update the dependencies array to be: [P.board, history]",{"range":"101","text":"102"},[1142,1149],"[keyHandler, value]",[635,644],"[P.board, history]"]