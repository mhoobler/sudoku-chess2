[{"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/index.tsx":"1","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/JoinGame.tsx":"2","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/reducers/index.ts":"3","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/CreateGame.tsx":"4","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/Home.tsx":"5","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/actions/userActions.ts":"6","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/reducers/game.ts":"7","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/HintCell.tsx":"8","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/Scoreboard/Scorecard.tsx":"9","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameFuncs.tsx":"10","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/InputCell.tsx":"11","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/App.tsx":"12","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/Scoreboard/index.tsx":"13","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/index.tsx":"14","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/index.tsx":"15","/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/store.ts":"16"},{"size":710,"mtime":1614266988422,"results":"17","hashOfConfig":"18"},{"size":983,"mtime":1614209266576,"results":"19","hashOfConfig":"18"},{"size":150,"mtime":1614209266610,"results":"20","hashOfConfig":"18"},{"size":753,"mtime":1614209266561,"results":"21","hashOfConfig":"18"},{"size":431,"mtime":1614209266567,"results":"22","hashOfConfig":"18"},{"size":703,"mtime":1614209266600,"results":"23","hashOfConfig":"18"},{"size":917,"mtime":1614209266607,"results":"24","hashOfConfig":"18"},{"size":941,"mtime":1614266287646,"results":"25","hashOfConfig":"18"},{"size":501,"mtime":1614266233732,"results":"26","hashOfConfig":"18"},{"size":5392,"mtime":1614209266423,"results":"27","hashOfConfig":"18"},{"size":1648,"mtime":1614266214783,"results":"28","hashOfConfig":"18"},{"size":1223,"mtime":1614266465533,"results":"29","hashOfConfig":"18"},{"size":2244,"mtime":1614266276410,"results":"30","hashOfConfig":"18"},{"size":2429,"mtime":1614266305671,"results":"31","hashOfConfig":"18"},{"size":4534,"mtime":1614266186480,"results":"32","hashOfConfig":"18"},{"size":233,"mtime":1614209266619,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"1j2uzk6",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"39"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"57"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"60","messages":"61","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"66","messages":"67","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/index.tsx",[],["70","71"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/JoinGame.tsx",[],["72","73"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/reducers/index.ts",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/CreateGame.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/pages/Home.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/actions/userActions.ts",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/reducers/game.ts",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/HintCell.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/Scoreboard/Scorecard.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameFuncs.tsx",["74"],"type getIndexes = (i: number, n: number) => number[];\n\n/* \nOh boi I get to explain this nightmare and you get to read it.\nThis file infers what the *Grid* state is base on the *Turns*\ninside the *Board* that delivered by the socket server.\n*/\n\nconst funcs = {\n  // This is the heart of this whole operation\n  // it creates the two arrays that will be used to help render the Grid's Cells\n  initGrid: (ta: Turn[], n: number) => {\n    let N = n * n;\n    let values = new Array(N * N).fill(0);\n    let players = new Array(N * N).fill(0);\n\n    /**************************\n    The order here is important\n    ***************************/\n    for (let i = 0; i < ta.length; i++) {\n      let turn = ta[i];\n      // First add the turn to the array\n      values[turn.index] = turn.value;\n      players[turn.index] = turn.player;\n\n      // Then get auto completes\n      let autos = funcs.autoComplete(turn.index, values, 3);\n      console.log(autos);\n      if (autos) {\n        for (let a of autos) {\n          if (a.value !== 0) {\n            values[a.index] = a.value;\n            players[a.index] = turn.player;\n          }\n        }\n      }\n    }\n\n    return { values, players };\n  },\n\n  // The next three functions help calculate how the Sudoku grid should be organized\n  // They only return INDEXES that are meant to point to one of the arrays from initGrid\n  // They do NOT return actual values from said arrays\n  getRow: (index: number, n: number) => {\n    let N = n * n;\n    let ri = ~~(index / N) * N;\n    let rowIndexes: number[] = Array.from(Array(N).keys()).map((e: number) => {\n      return ri + e;\n    });\n\n    return rowIndexes;\n  },\n\n  getCol: (index: number, n: number) => {\n    let N = n * n;\n    let ci = index % N;\n\n    let colIndexes: number[] = Array.from(Array(N).keys()).map((e: number) => {\n      return ci + N * e;\n    });\n\n    return colIndexes;\n  },\n\n  getBox: (index: number, n: number) => {\n    let N = n * n;\n    let rstart = ~~(index / (N * n));\n    let cstart = ~~((index % N) / n);\n    let start = rstart * N * n + cstart * n;\n    // console.log(start);\n\n    let boxIndexes: number[] = [];\n\n    for (let ri = 0; ri < n; ri++) {\n      for (let ci = 0; ci < n; ci++) {\n        boxIndexes.push(start + ci + ri * N);\n      }\n    }\n\n    return boxIndexes;\n  },\n\n  // This DOES return values, but inside of a set\n  // This is particularly useful for displaying Hints\n  getGroupSet: (index: number, arr: number[], n: number) => {\n    // console.time('getGroupSet');\n\n    let indexes = funcs\n      .getBox(index, n)\n      .concat(funcs.getCol(index, n))\n      .concat(funcs.getRow(index, n));\n    let all = indexes.map((e: number) => {\n      return arr[e];\n    });\n\n    let set = new Set(all);\n\n    // console.timeEnd('getGroupSet');\n    return set;\n  },\n\n  // Pretty simple, tests user input;\n  testInput: (index: number, arr: number[], n: number, value: number) => {\n    let set = funcs.getGroupSet(index, arr, n);\n\n    if (value > 0 && value <= n * n) {\n      if (set.has(value)) {\n        let indexes = Array.from(\n          new Set(\n            [\n              funcs.getRow(index, n),\n              funcs.getCol(index, n),\n              funcs.getBox(index, n),\n            ].flat()\n          )\n        );\n\n        return indexes.filter((e: number) => arr[e] === value);\n      } else {\n        return true;\n      }\n    } else {\n      return false;\n    }\n  },\n\n  // I'm sorry I almost completely forgot how this works\n  autoComplete: (\n    index: number,\n    arr: number[],\n    n: number,\n    autoArr: AutoComplete[] = []\n  ): any => {\n    let indexes = new Set(\n      [\n        funcs.getRow(index, n),\n        funcs.getCol(index, n),\n        funcs.getBox(index, n),\n      ].flat()\n    );\n\n    let found = Array.from(indexes)\n      .map((e: any) => {\n        return {\n          set: funcs.getGroupSet(e, arr, n),\n          index: e,\n        };\n      })\n      .filter((e) => e.set.size === n * n && arr[e.index] === 0);\n    console.log(found);\n\n    if (found.length > 0) {\n      let newArr = [...arr];\n\n      let autos = found.map((e) => {\n        e.set.delete(0);\n        let setArr = Array.from(e.set);\n        let boolArr = Array(n * n).fill(false);\n\n        for (let i = 0; i < setArr.length; i++) {\n          boolArr[setArr[i] - 1] = true;\n        }\n\n        let auto = {\n          index: e.index,\n          value: boolArr.findIndex((b: boolean) => !b) + 1,\n        };\n\n        newArr[auto.index] = auto.value;\n        found.forEach((e) => e.set.add(auto.value));\n\n        return auto;\n      });\n\n      // check if autocompleted cell will cause more autocompletes\n      let recusive = autos.map((e) => {\n        return funcs.autoComplete(e.index, newArr, n, [...autoArr, e]);\n      });\n\n      // let bigSet = new Set(autos.concat(recusive).flat());\n      let bigSet = autos.concat(recusive).flat();\n      console.log(bigSet);\n      return Array.from(bigSet);\n    } else {\n      // if no autocompletes were found, return what we got (or empty array)\n      return autoArr;\n    }\n  },\n};\n\nexport default funcs;\n/*     0        1        2\n0  00 01 02 03 04 05 06 07 08\n1  09 10 11 12 13 14 15 16 17 \n2  18 19 20 21 22 23 24 25 26 \n-      3        4        5\n3  27 28 29 30 31 32 33 34 35 \n4  36 37 38 39 40 41 42 43 44\n5  45 46 47 48 49 50 51 52 53 \n-      6        7        9\n6  54 55 56 57 58 59 60 61 62 \n7  63 64 65 66 67 68 69 70 71 \n8  72 73 74 75 76 77 78 79 80\n*/\n",["75","76"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/InputCell.tsx",["77"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/App.tsx",["78"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/Scoreboard/index.tsx",[],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/GameGrid/index.tsx",["79"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/Game/index.tsx",["80"],"/home/michael/Dev/HOMEWORK/sudoku-chess2/client/src/redux/store.ts",[],{"ruleId":"81","replacedBy":"82"},{"ruleId":"83","replacedBy":"84"},{"ruleId":"81","replacedBy":"85"},{"ruleId":"83","replacedBy":"86"},{"ruleId":"87","severity":1,"message":"88","line":1,"column":6,"nodeType":"89","messageId":"90","endLine":1,"endColumn":16},{"ruleId":"81","replacedBy":"91"},{"ruleId":"83","replacedBy":"92"},{"ruleId":"93","severity":1,"message":"94","line":39,"column":6,"nodeType":"95","endLine":39,"endColumn":13,"suggestions":"96"},{"ruleId":"93","severity":1,"message":"97","line":26,"column":6,"nodeType":"95","endLine":26,"endColumn":15,"suggestions":"98"},{"ruleId":"87","severity":1,"message":"99","line":1,"column":17,"nodeType":"89","messageId":"90","endLine":1,"endColumn":23},{"ruleId":"93","severity":1,"message":"100","line":69,"column":6,"nodeType":"95","endLine":69,"endColumn":24,"suggestions":"101"},"no-native-reassign",["102"],"no-negated-in-lhs",["103"],["102"],["103"],"@typescript-eslint/no-unused-vars","'getIndexes' is defined but never used.","Identifier","unusedVar",["102"],["103"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'keyHandler'. Either include it or remove the dependency array.","ArrayExpression",["104"],"React Hook useEffect has a missing dependency: 'history'. Either include it or remove the dependency array.",["105"],"'useRef' is defined but never used.","React Hook useEffect has missing dependencies: 'P', 'gameState.values', and 'n'. Either include them or remove the dependency array.",["106"],"no-global-assign","no-unsafe-negation",{"desc":"107","fix":"108"},{"desc":"109","fix":"110"},{"desc":"111","fix":"112"},"Update the dependencies array to be: [keyHandler, value]",{"range":"113","text":"114"},"Update the dependencies array to be: [P.board, history]",{"range":"115","text":"116"},"Update the dependencies array to be: [P, P.board, gameState.values, hasQuit, n]",{"range":"117","text":"118"},[1142,1149],"[keyHandler, value]",[635,644],"[P.board, history]",[1918,1936],"[P, P.board, gameState.values, hasQuit, n]"]